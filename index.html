<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Atkin Guitars Leave Calendar</title>

  <!-- prevent favicon 404 noise -->
  <link rel="icon" href="data:,">

  <!-- React / Tailwind / Babel (fine for prototyping; for prod, prebuild) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    .connection-indicator { position: fixed; top: 20px; right: 20px; z-index: 1000; padding: 8px 16px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 8px; transition: opacity 0.3s; }
    .connection-indicator.hide { opacity: 0; transform: translateX(100%); }
    .connected { background-color: #10B981; color: white; }
    .disconnected { background-color: #EF4444; color: white; }
    .sidebar { position: fixed; top: 0; left: 0; width: 280px; height: 100vh; background: white; box-shadow: 2px 0 10px rgba(0,0,0,0.1); transform: translateX(-100%); transition: transform 0.3s; z-index: 1000; }
    .sidebar.open { transform: translateX(0); }
    .sidebar-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 999; opacity: 0; visibility: hidden; transition: all 0.3s; }
    .sidebar-overlay.show { opacity: 1; visibility: visible; }
    .notification { position: fixed; top: 80px; right: 20px; z-index: 1000; padding: 12px 16px; border-radius: 8px; color: white; transform: translateX(100%); transition: transform 0.3s; }
    .notification.show { transform: translateX(0); }
    .notification.success { background-color: #10B981; }
    .notification.error { background-color: #EF4444; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Firebase v12 ESM init (PATCHED: new persistence + 'where' exposure) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
    import {
      initializeFirestore, persistentLocalCache, persistentMultipleTabManager,
      collection, doc, getDocs, getDoc, setDoc, deleteDoc,
      writeBatch, query, where, orderBy, Timestamp, onSnapshot
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyD8zcVQBrK_Q_WQZKa856u2ka901eakX0A",
      authDomain: "atkin-guitars-94dd8.firebaseapp.com",
      projectId: "atkin-guitars-94dd8",
      storageBucket: "atkin-guitars-94dd8.appspot.com",
      messagingSenderId: "501290829079",
      appId: "1:501290829079:web:e6d21711bccb47654ae352"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);

    // âœ… New, recommended local persistence (replaces enableIndexedDbPersistence)
    const db = initializeFirestore(app, {
      localCache: persistentLocalCache({
        tabManager: persistentMultipleTabManager()
      })
    });

    // Wait for anonymous auth
    const ready = new Promise((resolve) => {
      let resolved = false;
      onAuthStateChanged(auth, (user) => {
        if (user && !resolved) { resolved = true; resolve(user); }
      });
      signInAnonymously(auth).catch((err) => {
        console.error("Anon sign-in failed:", err);
        if (!resolved) resolve(null); // allow local fallback
      });
    });

    // Expose to the Babel script (includes 'where')
    window.__fb = {
      app, auth, db, ready,
      api: { collection, doc, getDocs, getDoc, setDoc, deleteDoc, writeBatch, query, where, orderBy, Timestamp, onSnapshot }
    };
  </script>
  <!-- App code -->
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    // Icon component
    const Icon = ({ name, className }) => {
      const paths = {
        calendar: "M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z",
        menu: "M4 6h16M4 12h16M4 18h16",
        users: "M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z",
        userAdd: "M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z",
        edit: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z",
        trash: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16",
        x: "M6 18L18 6M6 6l12 12",
        wifi: "M8.111 16.404a5.5 5.5 0 017.778 0M12 20h.01m-7.08-7.071c3.904-3.905 10.236-3.905 14.141 0M1.394 9.393c5.857-5.857 15.355-5.857 21.213 0",
        wifiOff: "M18.364 5.636l-12.728 12.728m0 0L1.394 14.122m4.242 4.242a5.5 5.5 0 007.778 0m7.778-7.778a10.97 10.97 0 00-3.536-2.464m-6.242 6.242L7.758 8.879m0 0a10.97 10.97 0 00-3.536 2.464",
        chevronLeft: "M15 19l-7-7 7-7",
        userGroup: "M17 20h5v-2a3 3 0 00-5.196-2.12M12 14a3 3 0 100-6 3 3 0 006 0zM7 20h10v-2a4 4 0 00-8 0v2z",
        home: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1m-6 0h6",
        settings: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756.426-1.756 2.924 0 3.35a1.724 1.724 0 001.066-2.573c-.94 1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z M15 12a3 3 0 11-6 0 3 3 0 016 0z",
        factory: "M8.25 21v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21m0 0h4.5V9.375c0-.621.504-1.125 1.125-1.125H20.25M8.25 21H3.75m0 0V9.375c0-.621.504-1.125 1.125-1.125H6.75m1.5 0V5.625c0-.621 1.125-1.125 1.125-1.125h4.5c.621 0 1.125 1.125 1.125 1.125v3.75M6 21V9a1 1 0 011-1h1m0 0h4m0 0h1v4M6 15h2m-2 3h2m5-9v9"
      };
      return (
        <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={paths[name]} />
        </svg>
      );
    };
    <!-- Firestore-backed Database API (PATCHED) -->
    <script type="text/babel">
    class DatabaseAPI {
      constructor(addNotificationCb) {
        this.addNotification = addNotificationCb || (() => {});
        this.fb = window.__fb || {};
        this.db = this.fb.db;
        this.auth = this.fb.auth;                 // needed to access current UID
        this.api = this.fb.api || {};
        this.unsubs = { employees: null, leaves: null, shutdowns: null };
      }

      _tsToDate(v) {
        if (!v) return null;
        if (v && typeof v.toDate === "function") return v.toDate();
        if (typeof v === "string") return new Date(v);
        return v instanceof Date ? v : null;
      }

      subscribeEmployees(setter) {
        if (!this.db) return () => {};
        const { collection, query, orderBy, onSnapshot } = this.api;
        const q = query(collection(this.db, "employees"), orderBy("name"));
        this.unsubs.employees?.();
        this.unsubs.employees = onSnapshot(q, (snap) => {
          setter(snap.docs.map(d => d.data()));
        });
        return this.unsubs.employees;
      }

      // only stream current user's leave docs
      subscribeLeaveRequests(setter) {
        if (!this.db) return () => {};
        const { collection, query, where, onSnapshot } = this.api;
        const uid = this.auth?.currentUser?.uid;
        const ref = query(collection(this.db, "leave_requests"), where("ownerId","==", uid));
        this.unsubs.leaves?.();
        this.unsubs.leaves = onSnapshot(ref, (snap) => {
          const rows = snap.docs.map(d => {
            const v = d.data();
            return {
              id: v.id ?? d.id,
              ...v,
              startDate: this._tsToDate(v.startDate),
              endDate: this._tsToDate(v.endDate)
            };
          });
          setter(rows);
        });
        return this.unsubs.leaves;
      }

      subscribeWorkshopShutdowns(setter) {
        if (!this.db) return () => {};
        const { collection, onSnapshot } = this.api;
        const ref = collection(this.db, "workshop_shutdowns");
        this.unsubs.shutdowns?.();
        this.unsubs.shutdowns = onSnapshot(ref, (snap) => {
          const rows = snap.docs.map(d => {
            const v = d.data();
            return { id: v.id ?? d.id, ...v, startDate: this._tsToDate(v.startDate), endDate: this._tsToDate(v.endDate) };
          });
          setter(rows);
        });
        return this.unsubs.shutdowns;
      }

      async fetchEmployees() {
        if (!this.db) {
          const stored = localStorage.getItem('atkin_employees');
          return stored ? JSON.parse(stored) : [
            { id: 1, name: 'Sarah Johnson', department: 'Workshop', totalLeave: 200, usedLeave: 64, avatar: 'SJ', color: '#3B82F6' },
            { id: 2, name: 'Michael Chen', department: 'Finishing', totalLeave: 160, usedLeave: 32, avatar: 'MC', color: '#10B981' },
            { id: 3, name: 'Emma Davis', department: 'Administration', totalLeave: 180, usedLeave: 96, avatar: 'ED', color: '#F59E0B' }
          ];
        }
        const { collection, getDocs, query, orderBy } = this.api;
        const snap = await getDocs(query(collection(this.db, "employees"), orderBy("name")));
        return snap.docs.map(d => d.data());
      }

      // only fetch current user's leave docs
      async fetchLeaveRequests() {
        if (!this.db) {
          const stored = localStorage.getItem('atkin_leave_requests');
          if (stored) return JSON.parse(stored).map(r => ({...r, startDate:new Date(r.startDate), endDate:new Date(r.endDate)}));
          return [{ id: 1, employeeId: 1, startDate: new Date(2025,7,25), endDate: new Date(2025,7,29), type: 'Annual Leave', status: 'approved', hours: 40 }];
        }
        const { collection, query, where, getDocs } = this.api;
        const uid = this.auth?.currentUser?.uid;
        const snap = await getDocs(query(collection(this.db, "leave_requests"), where("ownerId","==", uid)));
        return snap.docs.map(d => {
          const v = d.data();
          return {
            id: v.id ?? d.id,
            ...v,
            startDate: this._tsToDate(v.startDate),
            endDate: this._tsToDate(v.endDate)
          };
        });
      }

      async fetchWorkshopShutdowns() {
        if (!this.db) {
          const stored = localStorage.getItem('atkin_workshop_shutdowns');
          if (stored) return JSON.parse(stored).map(s => ({...s, startDate:new Date(s.startDate), endDate:new Date(s.endDate)}));
          return [];
        }
        const { collection, getDocs } = this.api;
        const snap = await getDocs(collection(this.db, "workshop_shutdowns"));
        return snap.docs.map(d => {
          const v = d.data();
          return { id: v.id ?? d.id, ...v, startDate: this._tsToDate(v.startDate), endDate: this._tsToDate(v.endDate) };
        });
      }

      async upsertEmployee(emp) {
        if (!this.db) {
          const arr = await this.fetchEmployees();
          const i = arr.findIndex(e => e.id === emp.id);
          if (i >= 0) arr[i] = emp; else arr.push(emp);
          localStorage.setItem('atkin_employees', JSON.stringify(arr));
          return;
        }
        const { doc, setDoc } = this.api;
        await setDoc(doc(this.db, "employees", String(emp.id)), emp, { merge: true });
      }

      async deleteEmployee(id) {
        if (!this.db) {
          const arr = (await this.fetchEmployees()).filter(e => e.id !== id);
          localStorage.setItem('atkin_employees', JSON.stringify(arr));
          return;
        }
        const { doc, deleteDoc } = this.api;
        await deleteDoc(doc(this.db, "employees", String(id)));
      }

      // write ownerId on create
      async createLeave(leave) {
        if (!this.db) {
          const arr = await this.fetchLeaveRequests();
          arr.push({ ...leave, id: `local-${Date.now()}` });
          localStorage.setItem('atkin_leave_requests', JSON.stringify(arr.map(r => ({...r, startDate:r.startDate.toISOString(), endDate:r.endDate.toISOString()}))));
          return;
        }
        const { collection, doc, setDoc } = this.api;
        const uid = this.auth?.currentUser?.uid;
        const ref = doc(collection(this.db, "leave_requests"));
        await setDoc(ref, { ...leave, id: ref.id, ownerId: uid });
      }

      async updateLeave(leaveId, partial) {
        if (!this.db) {
          const arr = await this.fetchLeaveRequests();
          const i = arr.findIndex(r => r.id === leaveId);
          if (i >= 0) {
            const merged = { ...arr[i], ...partial };
            arr[i] = merged;
            localStorage.setItem('atkin_leave_requests', JSON.stringify(arr.map(r => ({...r, startDate:new Date(r.startDate).toISOString(), endDate:new Date(r.endDate).toISOString()}))));
          }
          return;
        }
        const { doc, setDoc } = this.api;
        await setDoc(doc(this.db, "leave_requests", String(leaveId)), partial, { merge: true });
      }

      async deleteLeaveRequest(id) {
        if (!id) { console.warn("deleteLeaveRequest called without id"); return; }
        if (!this.db) {
          const arr = (await this.fetchLeaveRequests()).filter(r => r.id !== id);
          localStorage.setItem('atkin_leave_requests', JSON.stringify(arr.map(r => ({...r, startDate:r.startDate.toISOString(), endDate:r.endDate.toISOString()}))));
          return;
        }
        const { doc, deleteDoc } = this.api;
        await deleteDoc(doc(this.db, "leave_requests", String(id)));
      }

      async createShutdown(s) {
        if (!this.db) {
          const arr = await this.fetchWorkshopShutdowns();
          arr.push({ ...s, id: `local-${Date.now()}` });
          localStorage.setItem('atkin_workshop_shutdowns', JSON.stringify(arr.map(x => ({...x, startDate:x.startDate.toISOString(), endDate:x.endDate.toISOString()}))));
          return;
        }
        const { collection, doc, setDoc } = this.api;
        const ref = doc(collection(this.db, "workshop_shutdowns"));
        await setDoc(ref, { ...s, id: ref.id });
      }

      async updateShutdown(id, partial) {
        if (!this.db) {
          const arr = await this.fetchWorkshopShutdowns();
          const i = arr.findIndex(x => x.id === id);
          if (i >= 0) {
            arr[i] = { ...arr[i], ...partial };
            localStorage.setItem('atkin_workshop_shutdowns', JSON.stringify(arr.map(x => ({...x, startDate:new Date(x.startDate).toISOString(), endDate:new Date(x.endDate).toISOString()}))));
          }
          return;
        }
        const { doc, setDoc } = this.api;
        await setDoc(doc(this.db, "workshop_shutdowns", String(id)), partial, { merge: true });
      }

      async deleteWorkshopShutdown(id) {
        if (!this.db) {
          const arr = (await this.fetchWorkshopShutdowns()).filter(x => x.id !== id);
          localStorage.setItem('atkin_workshop_shutdowns', JSON.stringify(arr.map(x => ({...x, startDate:new Date(x.startDate).toISOString(), endDate:new Date(x.endDate).toISOString()}))));
          return;
        }
        const { doc, deleteDoc } = this.api;
        await deleteDoc(doc(this.db, "workshop_shutdowns", String(id)));
      }
    }
    ReactDOM.render(<LeaveCalendar />, document.getElementById('root'));
  </script>
</body>
</html>
